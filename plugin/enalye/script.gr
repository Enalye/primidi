/** 
 * Copyright: Enalye
 * License: Zlib
 * Authors: Enalye
 */
array(Canvas) canvases;
Canvas mainCanvas;
Texture spriteSheet, smallParticle, bigParticle;
let width, height = 1280f, 720f;
let barWidth, barFactor, hitFactor = 2f, 0f;
Color barColor;
float barX;

let colors = [
    [109, 247, 193],
    [17, 173, 193],
    [96, 108, 129],
    [57, 52, 87],
    [30, 136, 117],
    [91, 179, 97],
    [161, 229, 90],
    [247, 228, 118],
    [249, 146, 82],
    [203, 77, 104],
    [106, 55, 113],
    [201, 36, 100],
    [244, 140, 182],
    [247, 182, 158],
    [155, 156, 130],
    [49, 122, 215]
];

main {
    let centerX, centerY = width / 2f, height / 2f;
    Color baseBarColor;
    baseBarColor, barColor = Color(1f, 1f, 1f, 0.2f);
    spriteSheet = Texture("test.png");
    smallParticle = Texture("small.png");
    bigParticle = Texture("big.png");

    // Rendering canvas.
    setCameraSize(width, height);
    setCameraPosition(centerX, centerY);
    setCameraClearColor(Color(0.051, 0.082, 0.125));

    /*
        Default interval of ticks to be displayed.
        A too large value can cause slowdowns.
    */
    setInterval(6000);
    /*
        0 = note are hit on the right side of the screen.
        0.5 = in the center.
        1 = left side.
    */
    setRatio(0.8f);
    barX = width * (1f - getRatio()) - (barWidth / 2f);

    // We render each channel on a separate canvas.
    canvases = array(Canvas)[];
    loop(16) {
        let canvas = Canvas(width, height);
        canvas::setPosition(centerX, centerY);
        canvas::setColorMod(Color(1f, 1f, 1f), 3);
        canvases ~= canvas;
    }

    mainCanvas = Canvas(width, height);
    mainCanvas::setPosition(centerX, centerY);
    mainCanvas::setColorMod(Color(1f, 1f, 1f), 3);

    // Background
    let bg = Texture("background.png") as Sprite;
    bg::setSize(width, height);

    displayInfo();

    int time = 0;
    loop {
        if((time % 30) == 0)
            lightEffect();

        bg::draw(centerX, centerY);
        for(canvas, canvases) {
            canvas::draw(centerX, centerY);
            canvas::clear;
        }
        // Middle bar
        if(barFactor > 1f)
            barFactor = 1f;
        barColor:a = 0.6f;
        pushCanvas(mainCanvas);
        fillRect(barX, 0f, barWidth, height, lerp(baseBarColor, barColor, barFactor));
        popCanvas();
        if(barFactor < 0f) {
            barFactor = 0f;
        }
        else {
            barFactor -= 0.1f;
        }
        
        mainCanvas::draw(centerX, centerY);
        mainCanvas::clear;
        time ++;
        yield
    }
}

task lightEffect() {
    let color = Color(random(), random(), random(), 0.8f);
    let particle = createParticle(random(0f, width + 50f), -64f, random(95f, 105f), random(0.5f, 1f), 2_000);
    unless(particle) kill
    let sprite = smallParticle as Sprite;
    sprite::setBlend(2);

    float particleSize = 128f;
    if(random() >= 0.5f)
        particleSize = 64f;
    sprite::setSize(particleSize, particleSize);
    particle::setSprite(sprite);
    particle::setColor(color);
    float baseAngle = particle::getAngle;
    float time = 0f;
    while(particle::isAlive) {
        color:a = 0.6f + cos(time * 0.0123f) * 0.4f + barFactor * 0.4f;
        particle::setColor(color);
        sprite::setSize(particleSize + barFactor * particleSize * 2f, particleSize + particleSize * barFactor * 2f);
        particle::setAngle(baseAngle + cos(time * 0.01f) * 50f);
        time ++;
        yield
    }
}

task spark(float x, float y, float angle, float speed, int ttl, Color startColor, Color endColor) {
    let particle = createParticle(x, y, angle, speed, ttl);
    unless(particle) kill

    let sprite = bigParticle as Sprite;
    particle::setSprite(sprite);
    sprite::setSize(3f, 3f);
    sprite::setBlend(2);
    startColor:a = 1f;
    endColor:a = 1f;
    particle::setColor(startColor);
    float time = 0f;
    while(particle::isAlive) {
        particle::setColor(lerp(startColor, endColor, time / ttl));
        time ++;
        yield
    }
}

func wait(int duration) {
    loop(duration) yield
}

float displayInfoFactor = 0f;
Sprite trackTitle;
Font font;
bool isInfoRunning = false;
task displayInfo() {
    let coverSprite = Texture("cover.png") as Sprite;
    let shadowSprite = Texture("shadow.png") as Sprite;
    coverSprite::setSize(300f, 300f);
    shadowSprite::setSize(300f, 300f);

    font = Font("Cascadia.ttf", 32);
    trackTitle = font::createText("No Title");

    float coverX, coverY = width - 200f, 350f;

    Color infoColor = Color(1f, 1f, 1f);

    let barSprite = spriteSheet as Sprite;
    barSprite::setClip(16, 0, 1, 1);
    barSprite::setAnchor(1f, 1f);
    Color clear = Color(0f, 0f, 0f, 0f);

    loop {
        if(isInfoRunning and (getMidiTime() + 11_000f >= getMidiDuration())) {
            isInfoRunning = false;
            endTask();
        }
        float trackNameX = (width - trackTitle::getWidth / 2f) - 50f;

        infoColor:a = displayInfoFactor;
        coverSprite::setColor(infoColor);
        shadowSprite::setColor(infoColor);
        trackTitle::setColor(infoColor);
        shadowSprite::draw(coverX - 16f, coverY + 16f);
        coverSprite::draw(coverX, coverY);
        trackTitle::draw(trackNameX, height - 100f);

        if(displayInfoFactor > 0f)
            spark(width, ((height - 100f) - trackTitle::getHeight / 2f) + random(0f, trackTitle::getHeight), 180f, random(2f, 3f), 180, infoColor, clear);

        barSprite::setColor(infoColor);
        if(displayInfoFactor < 0.5f) {
            barSprite::setSize(lerp(0f, trackTitle::getWidth, easeInSine(displayInfoFactor * 2f)), 5f);
            barSprite::draw(trackNameX + trackTitle::getWidth / 2f, height - 70f);
        }
        else if(displayInfoFactor < 1f) {
            float t = easeOutSine((displayInfoFactor - 0.5f) * 2f);
            barSprite::setSize(lerp(trackTitle::getWidth, 0f, t), 5f);
            barSprite::draw(trackNameX + lerp((trackTitle::getWidth / 2f), -trackTitle::getWidth / 2f, t), height - 70f);
        }
        yield
    }
}

// Called when a midi file is starting.
event onStart() {
    trackTitle = font::createText(getMidiName());
    displayInfoFactor = 0f;
    wait(120);

    float time = 0f;
    while(isMidiPlaying()) {
        displayInfoFactor = lerp(0f, 1f, easeInOutSine(time));
        if(time > 1f) {
            displayInfoFactor = 1f;
            isInfoRunning = true;
            kill
        }
        time +=  0.0025f;
        yield
    }
}

// Called when a midi file is ending.
event onEnd() {
    if(isInfoRunning)
        endTask();
}

task endTask() {
    isInfoRunning = false;
    float time = 0f;
    displayInfoFactor = 0f;
    loop {
        displayInfoFactor = lerp(1f, 0f, easeInOutSine(time));
        if(time > 1f) {
            displayInfoFactor = 0f;
            kill
        }
        time +=  0.0025f;
        yield
    }
}

// Called for each note entering the Interval window.
event onNoteEnter(Note note) {
    bool wasHit = false;
    let centerSprite = spriteSheet as Sprite;
    centerSprite::setClip(16, 0, 1, 1);
    centerSprite::setAnchor(0f, 0f);

    Color color = colors[note::getChannel];

    let pitch = 1f - (note::getPitch as float / 128f);
    float fadeOut = 1f;
    int time = 0;

    loop {
        unless(note::isAlive)
            kill

        let w, h =
            width * note::getDuration,
            height / 128f;

        if(w < 4f)
            w = 4f;
        
        centerSprite::setSize(w, h);
        
        let x, y =
            width * (1f - note::getTime),
            height * pitch;

        if(note::isPlaying) {
            y -= getPitchBend(note::getChannel) * h * 2f;
            let factor = note::getPlayTime;
            let c = lerp(Color(1f, 1f, 1f, 1f), color, factor);
            centerSprite::setColor(c);

            // Particles
            let particleX = barX + barWidth;
            unless(wasHit) {
                wasHit = true;
                loop(i, 17) {
                    spark(particleX, y + h / 2f, -85f + (10f * i) + random(-6f, 6f), random(1.1f, 1.7f), random(5, 30), color, c);
                }
            }
            else if((time % 5) == 0) {
                spark(particleX, y, random(-85f, 5f), random(0.2f, 1.5f), random(5, 20), color, c);
                spark(particleX, y + h, random(5f, 85f), random(0.2f, 1.5f), random(5, 20), color, c);
            }
            barColor = mix(barColor, c);
            barFactor += (1f - factor) * 0.2f;
            hitFactor += barFactor;
        }
        else {
            if(note::getPlayTime > 0f) {
                centerSprite::setColor(lerp(Color(1f, 1f, 1f, 0f), color, fadeOut));
                if(fadeOut > 0f) {
                    fadeOut -= 0.025f;
                    if(fadeOut < 0f) {
                        fadeOut = 0f;
                    }
                }
            }
            else {
                centerSprite::setColor(Color(1f, 1f, 1f, 0.5f));
            }
        }
        pushCanvas(canvases[note::getChannel]);
        centerSprite::draw(x, y);
        popCanvas();
        time ++;
        yield
    }
}